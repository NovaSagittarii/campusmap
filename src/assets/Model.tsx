/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { MutableRefObject, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { ThreeElements } from "@react-three/fiber";
import { useFrame } from "@react-three/fiber";
import { func } from "three/examples/jsm/nodes/Nodes.js";
import { POI } from "../floorPlan";

export class aParams {
  destination: [number, number, number] = [0, 0, 0];
  trueDestination: [number, number, number] = [0, 0, 0];
  currPOI: POI | null = null;
  targetPOI: POI | null = null;
  velocity: [number, number, number] = [0, 0, 0];
  maxVelocity: number = 100;
  rotationForce: [number, number, number] = [0, 0, 0];
  headRotationForce: [number, number, number] = [0, 0, 0];
  status: string = "idle";
}

type ModelProps = ThreeElements["mesh"] & {
  animationParams: MutableRefObject<aParams>;
}

export function Model({ animationParams, ...props }: ModelProps) {
  const headRef = useRef<THREE.Mesh>(null);
  const bodyRef = useRef<THREE.Mesh>(null);
  const hairRef = useRef<THREE.Mesh>(null);
  const { nodes, materials } = useGLTF("/playermodel.gltf");

  useFrame((_, delta) => {
    if (!headRef.current || !bodyRef.current || !hairRef.current) return;
    // headRef.current.rotation.y += 0.01;
    // headRef.current.rotation.x += 0.01;
    // headRef.current.rotation.z += 0.01;
    // hairRef.current.rotation.y += 0.01;
    // hairRef.current.rotation.x += 0.01;
    // hairRef.current.rotation.z += 0.01;
    bodyRef.current.rotation.x += animationParams.current.rotationForce[0];
    bodyRef.current.rotation.y += animationParams.current.rotationForce[1];
    bodyRef.current.rotation.z += animationParams.current.rotationForce[2];
    if (animationParams.current.status === "moveTo") {
      const dx = animationParams.current.destination[0] - bodyRef.current.position.x;
      const dy = animationParams.current.destination[1] - bodyRef.current.position.y;
      const dz = animationParams.current.destination[2] - bodyRef.current.position.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
      if (dist > 0.001) {
        // use delta time clock.getDelta()
        const vx = dx / dist * animationParams.current.maxVelocity;
        const vy = dy / dist * animationParams.current.maxVelocity;
        const vz = dz / dist * animationParams.current.maxVelocity;
        animationParams.current.velocity = [vx, vy, vz];
      } else {
        animationParams.current.velocity = [0, 0, 0];
        animationParams.current.status = "idle";
      }

      bodyRef.current.position.x += Math.min(Math.abs(animationParams.current.velocity[0] * delta), Math.abs(dx)) * Math.sign(dx);
      bodyRef.current.position.y += Math.min(Math.abs(animationParams.current.velocity[1] * delta), Math.abs(dy)) * Math.sign(dy);
      bodyRef.current.position.z += Math.min(Math.abs(animationParams.current.velocity[2] * delta), Math.abs(dz)) * Math.sign(dz);
    }
  });

  return (
    <group {...props} dispose={null} ref={bodyRef}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Body.geometry}
        material={materials.Material}
        scale={[1, 0.927, 1]}
      />
      <mesh ref={headRef}
        castShadow
        receiveShadow
        geometry={nodes.Head.geometry}
        material={materials.Material}
        position={[0, 0.812, 0]}
        scale={0.626}
      />
      <mesh ref={hairRef}
        castShadow
        receiveShadow
        geometry={nodes.Hair.geometry}
        material={materials.Material}
        position={[0, 0.812, 0]}
        scale={0.626}
      />
    </group >
  );
}

useGLTF.preload("/playerModel.gltf");
